<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical setup · XCALibre.jl</title><meta name="title" content="Numerical setup · XCALibre.jl"/><meta property="og:title" content="Numerical setup · XCALibre.jl"/><meta property="twitter:title" content="Numerical setup · XCALibre.jl"/><meta name="description" content="Documentation for XCALibre.jl."/><meta property="og:description" content="Documentation for XCALibre.jl."/><meta property="twitter:description" content="Documentation for XCALibre.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">XCALibre.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/01_2d-isothermal-backward-facing-step/">Verification: 2D incompressible backward-facing step</a></li><li><a class="tocitem" href="../../examples/02_2d-incompressible-transient-cylinder/">Verification: 2D Unsteady incompressible cylinder</a></li><li><a class="tocitem" href="../../examples/03_2d-constant-temperature-flat-plate/">Validation: 2D Constant temperature flat plate</a></li><li><a class="tocitem" href="../../examples/04_2d-inflow-using-Flux/">Advanced: 2D inflow using <code>Flux.jl</code></a></li><li><a class="tocitem" href="../../examples/05_2d-aerofoil-inflow-optimisation/">Advanced: 2D Aerofoil inflow optimisation</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../0_introduction_and_workflow/">Introduction</a></li><li><a class="tocitem" href="../1_preprocessing/">Pre-processing</a></li><li><a class="tocitem" href="../2_physics_and_models/">Physics and models</a></li><li class="is-active"><a class="tocitem" href>Numerical setup</a><ul class="internal"><li><a class="tocitem" href="#Discretisation-schemes"><span>Discretisation schemes</span></a></li><li><a class="tocitem" href="#Linear-solvers"><span>Linear solvers</span></a></li></ul></li><li><a class="tocitem" href="../4_runtime_and_solvers/">Runtime and solvers</a></li><li><a class="tocitem" href="../5_postprocessing/">Post-processing</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../contributor_guide/">Contributor Guide</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Numerical setup</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical setup</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl/blob/main/docs/src/user_guide/3_numerical_setup.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-setup"><a class="docs-heading-anchor" href="#Numerical-setup">Numerical setup</a><a id="Numerical-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-setup" title="Permalink"></a></h1><p><em>Available discretisation schemes, linear solvers and preconditioners</em></p><h2 id="Discretisation-schemes"><a class="docs-heading-anchor" href="#Discretisation-schemes">Discretisation schemes</a><a id="Discretisation-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-schemes" title="Permalink"></a></h2><hr/><p>Part of the methodology to solve the various model equations using the Finite Volume Method (FVM) is to discretise each equation term, essentially, this process linearises the partial differential equation so that it can be represented as a system of linear equations, which can be solved using linear algebra along with iterative solvers. This section presents the discretisation schemes currently available in XCALibre.jl.</p><p>Discretisation schemes in XCALibre.jl are organised under the abstract type <code>AbstractScheme</code>. As shown previously, a list of available schemes can be found using the  <code>subtypes</code> function:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;">AbstractScheme
├─ BoundedUpwind
├─ CrankNicolson
├─ Euler
├─ LUST
├─ Linear
├─ Midpoint
├─ Orthogonal
├─ SteadyState
└─ Upwind</code></pre><h3 id="Schemes-available"><a class="docs-heading-anchor" href="#Schemes-available">Schemes available</a><a id="Schemes-available-1"></a><a class="docs-heading-anchor-permalink" href="#Schemes-available" title="Permalink"></a></h3><hr/><h4 id="Time-schemes"><a class="docs-heading-anchor" href="#Time-schemes">Time schemes</a><a id="Time-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Time-schemes" title="Permalink"></a></h4><table><tr><th style="text-align: left"><strong>Scheme</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left">SteadyState</td><td style="text-align: left">sets the time derivative to zero</td></tr><tr><td style="text-align: left">Euler</td><td style="text-align: left">First order implicit Euler scheme</td></tr><tr><td style="text-align: left">CrankNicolson</td><td style="text-align: left">Second order central scheme (not implemented yet)</td></tr></table><hr/><h4 id="Laplacian-schemes"><a class="docs-heading-anchor" href="#Laplacian-schemes">Laplacian schemes</a><a id="Laplacian-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Laplacian-schemes" title="Permalink"></a></h4><table><tr><th style="text-align: left"><strong>Scheme</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left">Linear</td><td style="text-align: left">2nd order Gauss gradient scheme with linear interpolation</td></tr></table><hr/><h4 id="Divergence-schemes"><a class="docs-heading-anchor" href="#Divergence-schemes">Divergence schemes</a><a id="Divergence-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Divergence-schemes" title="Permalink"></a></h4><table><tr><th style="text-align: left"><strong>Scheme</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left">Linear</td><td style="text-align: left">2nd order central difference</td></tr><tr><td style="text-align: left">Upwind</td><td style="text-align: left">1st order upwind scheme</td></tr><tr><td style="text-align: left">BoundedUpwind</td><td style="text-align: left">Bounded version of the Upwind scheme</td></tr><tr><td style="text-align: left">LUST</td><td style="text-align: left">1st/2nd order mixed scheme (fixed at 75% Linear - 25% Upwind)</td></tr></table><hr/><h4 id="Gradient-schemes"><a class="docs-heading-anchor" href="#Gradient-schemes">Gradient schemes</a><a id="Gradient-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-schemes" title="Permalink"></a></h4><table><tr><th style="text-align: left"><strong>Scheme</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left">Orthogonal</td><td style="text-align: left">Green-Gauss uncorrected gradient scheme</td></tr><tr><td style="text-align: left">Midpoint</td><td style="text-align: left">Green-Gauss skew corrected scheme (2 iterations - hardcoded)</td></tr></table><h4 id="Gradient-limiters"><a class="docs-heading-anchor" href="#Gradient-limiters">Gradient limiters</a><a id="Gradient-limiters-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-limiters" title="Permalink"></a></h4><table><tr><th style="text-align: left"><strong>Scheme</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left">FaceBased</td><td style="text-align: left">Limit gradient calculation based on face extrapolation</td></tr><tr><td style="text-align: left">MFaceBased</td><td style="text-align: left">Limit gradient calculation based on face extrapolation in multiple dimensions</td></tr></table><p>The construction of all gradient limiters currently requires users to pass the mesh object that will be used for the simulations e.g. <code>MFaceBased(mesh)</code>. Notice that the mesh object must be moved to the same device where the simulation will be performed. To prevent mistakes and avoid errors, it is recommended to construct the limiters using the simulation <code>Physics</code> object directly since it provide a reference to the mesh (domain) e.g. if a <code>Physics</code> object named <code>model</code> has been created, construct the limiter as <code>MFaceBased(model.domain)</code></p><hr/><h3 id="Specifying-schemes"><a class="docs-heading-anchor" href="#Specifying-schemes">Specifying schemes</a><a id="Specifying-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-schemes" title="Permalink"></a></h3><p>XCALibre.jl flow solvers offer considerable flexibility to users for defining discretisation schemes. However, this means that discretisation schemes must be specified for every term of every equation solved. The schemes must be provided as a <code>NamedTuple</code> where each keyword corresponds to the fields being solved, e.g. (U = ..., p = ..., k = ..., &lt;field&gt; = ...). To facilitate this process, the <a href="../../reference/#XCALibre.Discretise.set_schemes-Tuple{}"><code>set_schemes</code></a> function is provided. Used without any inputs <code>set_schemes</code> uses the default values provided (see details below).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.set_schemes-user_guide-3_numerical_setup" href="#XCALibre.Discretise.set_schemes-user_guide-3_numerical_setup"><code>XCALibre.Discretise.set_schemes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_schemes(;
    # keyword arguments and their default values
    time=SteadyState,
    divergence=Linear, 
    laplacian=Linear, 
    gradient=Orthogonal,
    limiter=nothing) = begin
    
    # Returns NamedTuple definition for scheme 
    (
        time=time,
        divergence=divergence,
        laplacian=laplacian,
        gradient=gradient,
        limiter=limiter
    )   
end</code></pre><p>The <code>set_schemes</code> function is used at the top-level API to help users define discretisation schemes for every field solved. It offers default values, thus users can pick and choose which entry they wish to modify.</p><p><strong>inputs</strong></p><ul><li><code>time</code> is used to set the time schemes (default is <code>SteadyState</code>)</li><li><code>divergence</code> is used to set the divergence scheme (default is <code>Linear</code>) </li><li><code>laplacian</code> is used to set the laplacian scheme (default is <code>Linear</code>)</li><li><code>gradient</code>  is used to set the gradient scheme (default is <code>Orthogonal</code>)</li><li><code>limiter</code> is used to specify if gradient limiters should be used, currently supported limiters include <code>FaceBased</code> and <code>MFaceBased</code> (default is <code>nothing</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/0877a96beecac53b4afa2a8cceb26743a6e877f0/src/Discretise/Discretise_4_assign_boundaries.jl#L164-L193">source</a></section></article><p>For example, below we set the schemes for the  <code>U</code> and <code>p</code> fields. Notice that in the first case the schemes will take their default values (entry for <code>p</code>). In the case of <code>U</code>, we are only changing the setting for the divergence scheme to <code>Upwind</code>.</p><pre><code class="language-julia hljs">using XCALibre

# Note: this example assumes a Physics object named `model` already exists

schemes = (
    p = set_schemes(), # no input provided (will use defaults)
    U = set_schemes(divergence = Upwind, gradient=Midpoint, limiter=MFaceBased(model.domain)),
)</code></pre><h2 id="Linear-solvers"><a class="docs-heading-anchor" href="#Linear-solvers">Linear solvers</a><a id="Linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solvers" title="Permalink"></a></h2><hr/><p>Linear solvers in XCALibre.jl are provided by <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl">Krylov.jl</a>. The following solvers types are re-exported in XCALibre.jl</p><ul><li><code>BicgstabSolver</code> is a general purpose linear solver. Works well with non-symmetric matrices e.g. for <code>U</code>.</li><li><code>CgSolver</code> is particular strong with symmetric matrices e.g to solve the pressure equation.</li><li><code>GmresSolver</code> is a general solver. We have found it works best on the CPU backend.</li></ul><p>For more information on these solvers you can review the excellent documentation provided by the <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl">Krylov.jl</a> team. </p><p>XCALibre.jl provides the <code>set_solver</code> convenience function for setting solvers. See details below. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solve.set_solver-user_guide-3_numerical_setup" href="#XCALibre.Solve.set_solver-user_guide-3_numerical_setup"><code>XCALibre.Solve.set_solver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_solver( 
    field::AbstractField;
    # keyword arguments and defaults
    solver::S, 
    preconditioner::PT, 
    convergence, 
    relax,
    smoother=nothing,
    limit=(),
    itmax::Integer=1000, 
    atol=(eps(_get_float(field.mesh)))^0.9,
    rtol=_get_float(field.mesh)(1e-1)
    ) where {S,PT&lt;:PreconditionerType} = begin

    # return NamedTuple
    TF = _get_float(field.mesh)
    (
        solver=solver, 
        preconditioner=preconditioner, 
        convergence=convergence |&gt; TF, 
        relax=relax |&gt; TF, 
        smoother=smoother,
        limit=limit,
        itmax=itmax, 
        atol=atol |&gt; TF, 
        rtol=rtol |&gt; TF
    )
end</code></pre><p>This function is used to provide solver settings that will be used internally in XCALibre.jl. It returns a <code>NamedTuple</code> with solver settings that are used internally by the flow solvers. </p><p><strong>Input arguments</strong></p><ul><li><code>field</code> reference to the field to which the solver settings will apply (used to provide integer and float types required)</li><li><code>solver</code> solver object from Krylov.jl and it could be one of <code>BicgstabSolver</code>, <code>CgSolver</code>, <code>GmresSolver</code> which are re-exported in XCALibre.jl</li><li><code>preconditioner</code> instance of preconditioner to be used e.g. Jacobi()</li><li><code>convergence</code> sets the stopping criteria of this field</li><li><code>relax</code> specifies the relaxation factor to be used e.g. set to 1 for no relaxation</li><li><code>smoother</code> specifies smoothing method to be applied before discretisation. <code>JacobiSmoother</code> is currently the only choice (defaults to <code>nothing</code>)</li><li><code>limit</code> used in some solvers to bound the solution within this limits e.g. (min, max). It defaults to <code>()</code></li><li><code>itmax</code> maximum number of iterations in a single solver pass (defaults to 1000) </li><li><code>atol</code> absolute tolerance for the solver (default to eps(FloatType)^0.9)</li><li><code>rtol</code> set relative tolerance for the solver (defaults to 1e-1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/0877a96beecac53b4afa2a8cceb26743a6e877f0/src/Solve/Solve_1_api.jl#L7-L51">source</a></section></article><h3 id="Preconditioners"><a class="docs-heading-anchor" href="#Preconditioners">Preconditioners</a><a id="Preconditioners-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioners" title="Permalink"></a></h3><p>XCALibre.jl offers a range of preconditioners which are subtypes of the abstract type <code>PreconditionerType</code>, exploring its subtypes we can find a list of the currently available preconditioners: </p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;">PreconditionerType
├─ LDIVPreconditioner
│  └─ DILU
└─ MULPreconditioner
   ├─ IC0GPU
   ├─ ILU0GPU
   ├─ Jacobi
   └─ NormDiagonal</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only the <code>Jacobi</code> and <code>NormDiagonal</code> preconditioners have GPU ready implementations. At present these have the most robust implementation and they can be used with both CPU and GPU backends. The other preconditioners can only be used on the CPU. Notice that on our tests the <code>LDL</code> preconditioner only works when paired with the <code>GmresSolver</code> on the CPU. Also notice that the implementations for <code>DILU</code> (experimental), <code>IC0GPU</code> and <code>ILU0GPU</code> (NVIDIA only), should be considered experimental. Work on improving the offering of preconditioners is ongoing.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internally the storage for sparse matrices was moved to the CSR format. Thus, temporarily, we have removed support for <code>LDL</code> and <code>ILU0</code> preconditioners while we work on CSR compatible implementations. </p></div></div><p>Below an example is provided in context. Here, we are setting solvers for both the velocity field <code>U</code> and the pressure field <code>p</code> and packing them into a <code>NamedTuple</code> &quot;solvers&quot;. The <code>Jacobi</code> preconditioner is used in both solvers. Notice that preconditioners are specified with an instance of their type i.e. <code>Jacobi()</code>. Internally, the preconditioner instance is used for dispatch. This tupple will then be passed on to create the final <code>Configuration</code> object.</p><pre><code class="language-julia hljs">using XCALibre

# Note: this example assumes a Physics object named `model` already exists

solvers = (
    U = set_solver(
        model.momentum.U;
        solver      = BicgstabSolver, # GmresSolver
        preconditioner = Jacobi(),
        convergence = 1e-7,
        relax       = 0.7,
        rtol = 1e-4,
        atol = 1e-10
    ),
    p = set_solver(
        model.momentum.p;
        solver      = CgSolver, # BicgstabSolver, GmresSolver
        preconditioner = Jacobi(),
        convergence = 1e-7,
        relax       = 0.7,
        rtol = 1e-4,
        atol = 1e-10
    )
)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2_physics_and_models/">« Physics and models</a><a class="docs-footer-nextpage" href="../4_runtime_and_solvers/">Runtime and solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 9 March 2025 00:15">Sunday 9 March 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
