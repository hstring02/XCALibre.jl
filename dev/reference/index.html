<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · XCALibre.jl</title><meta name="title" content="Reference · XCALibre.jl"/><meta property="og:title" content="Reference · XCALibre.jl"/><meta property="twitter:title" content="Reference · XCALibre.jl"/><meta name="description" content="Documentation for XCALibre.jl."/><meta property="og:description" content="Documentation for XCALibre.jl."/><meta property="twitter:description" content="Documentation for XCALibre.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">XCALibre.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/01_2d-isothermal-backward-facing-step/">Verification: 2D incompressible backward-facing step</a></li><li><a class="tocitem" href="../examples/02_2d-incompressible-transient-cylinder/">Verification: 2D Unsteady incompressible cylinder</a></li><li><a class="tocitem" href="../examples/03_2d-constant-temperature-flat-plate/">Validation: 2D Constant temperature flat plate</a></li><li><a class="tocitem" href="../examples/04_2d-inflow-using-Flux/">Advanced: 2D inflow using <code>Flux.jl</code></a></li><li><a class="tocitem" href="../examples/05_2d-aerofoil-inflow-optimisation/">Advanced: 2D Aerofoil inflow optimisation</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../user_guide/0_introduction_and_workflow/">Introduction</a></li><li><a class="tocitem" href="../user_guide/1_preprocessing/">Pre-processing</a></li><li><a class="tocitem" href="../user_guide/2_physics_and_models/">Physics and models</a></li><li><a class="tocitem" href="../user_guide/3_numerical_setup/">Numerical setup</a></li><li><a class="tocitem" href="../user_guide/4_runtime_and_solvers/">Runtime and solvers</a></li><li><a class="tocitem" href="../user_guide/5_postprocessing/">Post-processing</a></li></ul></li><li><a class="tocitem" href="../contributor_guide/">Contributor Guide</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Boundary" href="#XCALibre.Mesh.Boundary"><code>XCALibre.Mesh.Boundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Boundary{S&lt;:Symbol, UR&lt;:UnitRange{&lt;:Integer}}
    name::S         # Boundary patch name
    IDs_range::UR   # range to access boundary info (faces and boundary_cellsID)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Mesh/Mesh_0_types.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Cell" href="#XCALibre.Mesh.Cell"><code>XCALibre.Mesh.Cell</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Cell{F&lt;:AbstractFloat, SV3&lt;:SVector{3,F},UR&lt;:UnitRange{&lt;:Integer}}
    centre::SV3     # coordinate of cell centroid
    volume::F       # cell volume
    nodes_range::UR # range to access cell nodes in Mesh3.cell_nodes
    faces_range::UR # range to access cell faces info (faces, neighbours cells, etc.)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Mesh/Mesh_0_types.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Face3D" href="#XCALibre.Mesh.Face3D"><code>XCALibre.Mesh.Face3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Face3D{
    F&lt;:AbstractFloat, 
    SV2&lt;:SVector{2,&lt;:Integer},
    SV3&lt;:SVector{3,F}, 
    UR&lt;:UnitRange{&lt;:Integer}
    }
    
    nodes_range::UR # range to access face nodes in Mesh3.face_nodes
    ownerCells::SV2 # IDs of face owner cells (always 2)
    centre::SV3     # coordinates of face centre
    normal::SV3     # face normal unit vector
    e::SV3          # unit vector in the direction between owner cells
    area::F         # face area
    delta::F        # distance between owner cells centres
    weight::F       # linear interpolation weight
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Mesh/Mesh_0_types.jl#L81-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Mesh3" href="#XCALibre.Mesh.Mesh3"><code>XCALibre.Mesh.Mesh3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Mesh3{VC, VI, VF&lt;:AbstractArray{&lt;:Face3D}, VB, VN, SV3, UR} &lt;: AbstractMesh
    cells::VC           # vector of cells
    cell_nodes::VI      # vector of indices to access cell nodes
    cell_faces::VI      # vector of indices to access cell faces
    cell_neighbours::VI # vector of indices to access cell neighbours
    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )
    faces::VF           # vector of faces
    face_nodes::VI      # vector of indices to access face nodes
    boundaries::VB      # vector of boundaries
    nodes::VN           # vector of nodes
    node_cells::VI      # vector of indices to access node cells
    get_float::SV3      # store mesh float type
    get_int::UR         # store mesh integer type
    boundary_cellsID::VI # vector of indices of boundary cell IDs
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Mesh/Mesh_0_types.jl#L150-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Node" href="#XCALibre.Mesh.Node"><code>XCALibre.Mesh.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Node{SV3&lt;:SVector{3,&lt;:AbstractFloat}, UR&lt;:UnitRange{&lt;:Integer}}
    coords::SV3     # node coordinates
    cells_range::UR # range to access neighbour cells in Mesh3.node_cells
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Mesh/Mesh_0_types.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.UNV2.UNV2D_mesh-Tuple{Any}" href="#XCALibre.UNV2.UNV2D_mesh-Tuple{Any}"><code>XCALibre.UNV2.UNV2D_mesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UNV2D_mesh(meshFile; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 2D UNV mesh file into XCALibre.jl</p><p><strong>Input</strong></p><ul><li><code>meshFile</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/UNV2/UNV2_3_builder.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.UNV3.UNV3D_mesh-Tuple{Any}" href="#XCALibre.UNV3.UNV3D_mesh-Tuple{Any}"><code>XCALibre.UNV3.UNV3D_mesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UNV3D_mesh(unv_mesh; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 3D UNV mesh file into XCALibre.jl. Note that a limitation of the .unv mesh format is that it only supports the following 3D cells:</p><ul><li>Tetahedrals</li><li>Prisms</li><li>Hexahedrals</li></ul><p><strong>Input</strong></p><ul><li><code>unv_mesh</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/UNV3/UNV3_2_builder.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.FoamMesh.FOAM3D_mesh-Tuple{Any}" href="#XCALibre.FoamMesh.FOAM3D_mesh-Tuple{Any}"><code>XCALibre.FoamMesh.FOAM3D_mesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FOAM3D_mesh(mesh_file; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 3D OpenFOAM mesh file into XCALibre.jl. Note that, at present, it is not recommended to run 2D cases using meshes imported using this function.</p><p><strong>Input</strong></p><ul><li><code>mesh_file</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/FoamMesh/FoamMesh_5_build.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Multithread.activate_multithread-Tuple{CPU}" href="#XCALibre.Multithread.activate_multithread-Tuple{CPU}"><code>XCALibre.Multithread.activate_multithread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function activate_multithread(backend::CPU)

    BLAS.set_num_threads(1)

    @eval function  mul!(y::AbstractVector, A::SparseMatrixCSR, x::AbstractVector, alpha::Number, beta::Number)
        return xmul!(y, A, x, alpha, beta)
    end

    @eval function  mul!(y::AbstractVector, A::SparseMatrixCSR, x::AbstractVector)
        return xmul!(y, A, x, true, false)
    end

    @eval function  *(A::SparseMatrixCSR, x::AbstractVector)
        return xmul(A, x)
    end

    nothing
end</code></pre><p>Function to activate multithreading for CSR sparse matrices. The only input required is the backend (which must be <code>CPU()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Multithread/spmvm.jl#L82-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Fields.ScalarField" href="#XCALibre.Fields.ScalarField"><code>XCALibre.Fields.ScalarField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ScalarField{VF,M&lt;:AbstractMesh,BC} &lt;: AbstractScalarField
    values::VF  # scalar values at cell centre
    mesh::M     # reference to mesh
    BCs::BC     # store user-provided boundary conditions
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Fields/Fields_0_types.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Fields.VectorField" href="#XCALibre.Fields.VectorField"><code>XCALibre.Fields.VectorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VectorField{S1&lt;:ScalarField,S2,S3,M&lt;:AbstractMesh,BC} &lt;: AbstractVectorField
    x::S1   # x-component is itself a `ScalarField`
    y::S2   # y-component is itself a `ScalarField`
    z::S3   # z-component is itself a `ScalarField`
    mesh::M
    BCs::BC
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Fields/Fields_0_types.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Fields.initialise!-Tuple{Any, Any}" href="#XCALibre.Fields.initialise!-Tuple{Any, Any}"><code>XCALibre.Fields.initialise!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function initialise!(field, value) # dummy function for documentation
    # Assign `value` to field in-place
    nothing
end</code></pre><p>This function will set the given <code>field</code> to the <code>value</code> provided in-place. Useful for initialising fields prior to running a simulation.</p><p><strong>Input arguments</strong></p><ul><li><code>field</code> specifies the field to be initialised. The field must be either a <code>AbractScalarField</code> or <code>AbstractVectorField</code></li><li><code>value</code> defines the value to be set. This should be a scalar or vector (3 components) depending on the field to be modified e.g. for an <code>AbstractVectorField</code> we can specify as <code>value=[10,0,0]</code></li></ul><p>Note: in most cases the fields to be modified are stored within a physics model i.e. a <code>Physics</code> object. Thus, the argument <code>value</code> must fully qualify the model. For example, if we have created a <code>Physics</code> model named <code>mymodel</code> to set the velocity field, <code>U</code>, we would set the argument <code>field</code> to <code>mymodel.momentum.U</code>. See the example below.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">initialise!(mymodel.momentum.U, [2.5, 0, 0])
initialise!(mymodel.momentum.p, 1.25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Fields/Fields_0_types.jl#L239-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.Dirichlet" href="#XCALibre.Discretise.Dirichlet"><code>XCALibre.Discretise.Dirichlet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dirichlet &lt;: AbstractDirichlet</code></pre><p>Dirichlet boundary condition model.</p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li><li><code>value</code> – Scalar or Vector value for Dirichlet boundary condition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/dirichlet.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.DirichletFunction" href="#XCALibre.Discretise.DirichletFunction"><code>XCALibre.Discretise.DirichletFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirichletFunction(ID, value) &lt;: AbstractDirichlet</code></pre><p>Dirichlet boundary condition defined with user-provided function.</p><p><strong>Input</strong></p><ul><li><code>ID</code> Boundary name provided as symbol e.g. :inlet</li><li><code>value</code> Custom function for Dirichlet boundary condition.</li></ul><p><strong>Function requirements</strong></p><p>The function passed to this boundary condition must have the following signature:</p><pre><code class="nohighlight hljs">f(coords, time, index) = SVector{3}(ux, uy, uz)</code></pre><p>Where, <code>coords</code> is a vector containing the coordinates of a face, <code>time</code> is the current time in transient simulations (and the iteration number in steady simulations), and <code>index</code> is the local face index (from 1 to <code>N</code>, where <code>N</code> is the number of faces in a given boundary). The function must return an SVector (from StaticArrays.jl) representing the velocity vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/dirichletFunction.jl#L6-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.FixedTemperature" href="#XCALibre.Discretise.FixedTemperature"><code>XCALibre.Discretise.FixedTemperature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedTemperature &lt;: AbstractDirichlet</code></pre><p>Fixed temperature boundary condition model, which allows the user to specify wall temperature that can be translated to the energy specific model, such as sensivle enthalpy.</p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li><li><code>value</code> – Scalar or Vector value for Dirichlet boundary condition.</li><li><code>T</code> - Temperature value in Kelvin.</li><li><code>model</code> - Energy physics model for case.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">FixedTemperature(:inlet, T=300.0, model=model.energy),</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/fixedTemperature.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.Neumann" href="#XCALibre.Discretise.Neumann"><code>XCALibre.Discretise.Neumann</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Neumann &lt;: AbstractNeumann</code></pre><p>Neumann boundary condition model <em>(currently only configured for zero gradient)</em></p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li><li><code>value</code> – Scalar or Vector value for Neumann boundary condition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/neumann.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.Periodic" href="#XCALibre.Discretise.Periodic"><code>XCALibre.Discretise.Periodic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Periodic{I,V} &lt;: AbstractPhysicalConstraint
    ID::I
    value::V
end</code></pre><p>Periodic boundary condition model.</p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li><li><code>value</code> – tuple containing information needed to apply this boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/periodic.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.Symmetry" href="#XCALibre.Discretise.Symmetry"><code>XCALibre.Discretise.Symmetry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Symmetry &lt;: AbstractBoundary</code></pre><p>Symmetry boundary condition vector fields. For scalar fields use <code>Neumann</code></p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/symmetry.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.Wall" href="#XCALibre.Discretise.Wall"><code>XCALibre.Discretise.Wall</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Wall &lt;: AbstractDirichlet</code></pre><p>Wall boundary condition model for no-slip wall condition.</p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/wall.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.construct_periodic-Tuple{Any, Any, Symbol, Symbol}" href="#XCALibre.Discretise.construct_periodic-Tuple{Any, Any, Symbol, Symbol}"><code>XCALibre.Discretise.construct_periodic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_periodic(mesh, backend, patch1::Symbol, patch2::Symbol)</code></pre><p>Function for construction of periodic boundary conditions.</p><p><strong>Input</strong></p><ul><li><code>mesh</code> – Mesh.</li><li><code>backend</code>  – Backend configuraton.</li><li><code>patch1</code>  – Primary periodic patch ID.</li><li><code>patch2</code>   – Neighbour periodic patch ID.</li></ul><p><strong>Output</strong></p><ul><li><p>periodic::Tuple - tuple containing boundary defintions for <code>patch1</code> and <code>patch2</code> i.e. (periodic1, periodic2). The fields of <code>periodic1</code> and <code>periodic2</code> are </p><ul><li><code>ID</code> – Index to access boundary information in mesh object</li><li><code>value</code> – represents a <code>NamedTuple</code> with the following keyword arguments:<ul><li>index – ID used to find boundary geometry information in the mesh object</li><li>distance – perpendicular distance between the patches</li><li>face_map – vector providing indeces to faces of match patch</li><li>ismaster – flat to identify one of the patch pairs as the main patch</li></ul></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">- `periodic = construct_periodic(mesh, CPU(), :top, :bottom)` - Example using CPU 
backend with periodic boundaries named `top` and `bottom`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/periodic.jl#L37-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.set_schemes-Tuple{}" href="#XCALibre.Discretise.set_schemes-Tuple{}"><code>XCALibre.Discretise.set_schemes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_schemes(;
    # keyword arguments and their default values
    time=SteadyState,
    divergence=Linear, 
    laplacian=Linear, 
    gradient=Orthogonal) = begin
    
    # Returns NamedTuple definition for scheme 
    (
        time=time,
        divergence=divergence,
        laplacian=laplacian,
        gradient=gradient
    )
end</code></pre><p>The <code>set_schemes</code> function is used at the top-level API to help users define discretisation schemes for every field solved. It offers default values, thus users can pick and choose which entry they wish to modify.</p><p><strong>inputs</strong></p><ul><li><code>time</code> is used to set the time schemes (default is <code>SteadyState</code>)</li><li><code>divergence</code> is used to set the divergence scheme (default is <code>Linear</code>) </li><li><code>laplacian</code> is used to set the laplacian scheme (default is <code>Linear</code>)</li><li><code>gradient</code>  is used to set the gradient scheme (default is <code>Orthogonal</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/Discretise_4_assign_boundaries.jl#L164-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.@define_boundary-Tuple{Any, Any, Any}" href="#XCALibre.Discretise.@define_boundary-Tuple{Any, Any, Any}"><code>XCALibre.Discretise.@define_boundary</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">macro define_boundary(boundary, operator, definition)
    quote
        @inline (bc::$boundary)(
            term::Operator{F,P,I,$operator}, cellID, zcellID, cell, face, fID, i, component, time
            ) where {F,P,I} = $definition
    end |&gt; esc
end</code></pre><p>Macro to reduce boilerplate code when defining boundary conditions (implemented as functors) and provides access to key fields needed in the implementation of boundary conditions, such as the boundary cell and face objects (more details below)</p><p><strong>Input arguments</strong></p><ul><li><code>boundary</code> specifies the boundary type being defined</li><li><code>operator</code> specifies the operator to which the condition applies e.g. <code>Laplacian</code></li><li><code>definition</code> provides the implementation details</li></ul><p><strong>Available fields</strong></p><ul><li><code>term</code> reference to operator on which the boundary applies (gives access to the field and mesh) </li><li><code>cellID</code> ID of the corresponding boundary cell</li><li><code>zcellID</code> sparse matrix linear index for the cell</li><li><code>cell</code> gives access to boundary cell object and corresponding information</li><li><code>face</code> gives access to boundary face object and corresponding information</li><li><code>fID</code> ID of the boundary face (to index <code>Mesh2.faces</code> vector)</li><li><code>i</code> local index of the boundary faces within a kernel or loop</li><li><code>component</code> for vectors this specifies the components being evaluated (access as <code>component.value</code>). For scalars <code>component = nothing</code></li><li><code>time</code> provides the current simulation time. This only applies to time dependent boundary implementation defined as functions or neural networks.</li></ul><p><strong>Example</strong></p><p>Below the use of this macro is illustrated for the implementation of a  <code>Dirichlet</code> boundary condition acting on the <code>Laplacian</code> using the <code>Linear</code> scheme:</p><pre><code class="nohighlight hljs">@define_boundary Dirichlet Laplacian{Linear} begin
    J = term.flux[fID]      # extract operator flux
    (; area, delta) = face  # extract boundary face information
    flux = J*area/delta     # calculate the face flux
    ap = term.sign*(-flux)  # diagonal (cell) matrix coefficient
    ap, ap*bc.value         # return `ap` and `an`
end</code></pre><p>When called, this functor will return two values <code>ap</code> and <code>an</code>, where <code>ap</code> is the cell contribution for approximating the boundary face value, and <code>an</code> is the explicit part of the face value approximation i.e. <code>ap</code> contributes to the diagonal of the sparse matrix (left-hand side) and <code>an</code> is the explicit contribution assigned to the solution vector <code>b</code> on the right-hand of the linear system of equations <span>$Ax = b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Discretise/boundary_conditions/0_definition_macro.jl#L2-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solve.JacobiSmoother" href="#XCALibre.Solve.JacobiSmoother"><code>XCALibre.Solve.JacobiSmoother</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct JacobiSmoother{L,F,V} &lt;: AbstractSmoother
    loops::L
    omega::F
    x_temp::V
end</code></pre><p>Structure to hold information for using the weighted Jacobi smoother. </p><p><strong>Fields</strong></p><ul><li><code>loops</code> represents the number of smoothing iterations.</li><li><code>omega</code> represents the relaxation weight, 1 corresponds to no weighting. Typically a weight of 2/3 is used to filter high frequencies in the residual field.</li><li><code>x_temp</code> is a vector used internally to store intermediate solutions.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">JacobiSmoother(mesh::AbstractMesh)</code></pre><p>This constructor takes a mesh object as input to create the smoother. The number of cells in the mesh is used to allocate <code>x_temp</code>. The number of loops and smoother factor are set to 5 and 1, respectively.</p><pre><code class="nohighlight hljs">JacobiSmoother(; domain, loops, omega=2/3)</code></pre><p>Alternative constructor for <code>JacobiSmoother</code>.</p><p><strong>keyword arguments</strong></p><ul><li><code>domain</code> represents a mesh object of type <code>AbstractMesh</code>.</li><li><code>loops</code> is the number of iterations to be used</li><li><code>omega</code> represents the weighting factor, 1 does not relax the system, 2/3 is found to work well for smoothing high frequencies in the residual field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solve/Smoothers/Smoothers_jacobi.jl#L5-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solve.set_runtime-Union{Tuple{}, Tuple{N}, Tuple{I}} where {I&lt;:Integer, N&lt;:Number}" href="#XCALibre.Solve.set_runtime-Union{Tuple{}, Tuple{N}, Tuple{I}} where {I&lt;:Integer, N&lt;:Number}"><code>XCALibre.Solve.set_runtime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_runtime(; 
    # keyword arguments
    iterations::I, 
    write_interval::I, 
    time_step::N
    ) where {I&lt;:Integer,N&lt;:Number} = begin
    
    # returned `NamedTuple`
        (
        iterations=iterations, 
        dt=time_step, 
        write_interval=write_interval)
end</code></pre><p>This is a convenience function to set the top-level runtime information. The inputs are all keyword arguments and provide basic information to flow solvers just before running a simulation.</p><p><strong>Input arguments</strong></p><ul><li><code>iterations::Integer</code> specifies the number of iterations in a simulation run.</li><li><code>write_interval::Integer</code> defines how often simulation results are written to file (on the current working directory). The interval is currently based on number of iterations. Set to <code>-1</code> to run without writing results to file.</li><li><code>time_step::Number</code> the time step to use in the simulation. Notice that for steady solvers this is simply a counter and it is recommended to simply use <code>1</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">runtime = set_runtime(
    iterations=2000, time_step=1, write_interval=2000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solve/Solve_1_api.jl#L82-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solve.set_solver-Union{Tuple{AbstractField}, Tuple{PT}, Tuple{S}} where {S, PT&lt;:PreconditionerType}" href="#XCALibre.Solve.set_solver-Union{Tuple{AbstractField}, Tuple{PT}, Tuple{S}} where {S, PT&lt;:PreconditionerType}"><code>XCALibre.Solve.set_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_solver( 
    field::AbstractField;
    # keyword arguments and defaults
    solver::S, 
    preconditioner::PT, 
    convergence, 
    relax,
    smoother=nothing,
    limit=(),
    itmax::Integer=1000, 
    atol=(eps(_get_float(field.mesh)))^0.9,
    rtol=_get_float(field.mesh)(1e-1)
    ) where {S,PT&lt;:PreconditionerType} = begin

    # return NamedTuple
    TF = _get_float(field.mesh)
    (
        solver=solver, 
        preconditioner=preconditioner, 
        convergence=convergence |&gt; TF, 
        relax=relax |&gt; TF, 
        smoother=smoother,
        limit=limit,
        itmax=itmax, 
        atol=atol |&gt; TF, 
        rtol=rtol |&gt; TF
    )
end</code></pre><p>This function is used to provide solver settings that will be used internally in XCALibre.jl. It returns a <code>NamedTuple</code> with solver settings that are used internally by the flow solvers. </p><p><strong>Input arguments</strong></p><ul><li><code>field</code> reference to the field to which the solver settings will apply (used to provide integer and float types required)</li><li><code>solver</code> solver object from Krylov.jl and it could be one of <code>BicgstabSolver</code>, <code>CgSolver</code>, <code>GmresSolver</code> which are re-exported in XCALibre.jl</li><li><code>preconditioner</code> instance of preconditioner to be used e.g. Jacobi()</li><li><code>convergence</code> sets the stopping criteria of this field</li><li><code>relax</code> specifies the relaxation factor to be used e.g. set to 1 for no relaxation</li><li><code>smoother</code> specifies smoothing method to be applied before discretisation. <code>JacobiSmoother</code> is currently the only choice (defaults to <code>nothing</code>)</li><li><code>limit</code> used in some solvers to bound the solution within this limits e.g. (min, max). It defaults to <code>()</code></li><li><code>itmax</code> maximum number of iterations in a single solver pass (defaults to 1000) </li><li><code>atol</code> absolute tolerance for the solver (default to eps(FloatType)^0.9)</li><li><code>rtol</code> set relative tolerance for the solver (defaults to 1e-1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solve/Solve_1_api.jl#L7-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Compressible" href="#XCALibre.ModelPhysics.Compressible"><code>XCALibre.ModelPhysics.Compressible</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Compressible &lt;: AbstractCompressible</code></pre><p>Compressible fluid model containing fluid field parameters for compressible flows with      constant parameters - ideal gas with constant viscosity.</p><p><strong>Fields</strong></p><ul><li>&#39;nu&#39;   – Fluid kinematic viscosity.</li><li>&#39;cp&#39;   – Fluid specific heat capacity.</li><li><code>gamma</code> – Ratio of specific heats.</li><li><code>Pr</code>   – Fluid Prantl number.</li></ul><p><strong>Examples</strong></p><ul><li><code>Fluid{Compressible}(; nu=1E-5, cp=1005.0, gamma=1.4, Pr=0.7)</code> - Constructur with default values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/2_fluid_models.jl#L110-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Fluid" href="#XCALibre.ModelPhysics.Fluid"><code>XCALibre.ModelPhysics.Fluid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fluid &lt;: AbstractFluid</code></pre><p>Abstract fluid model type for constructing new fluid models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/2_fluid_models.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Incompressible" href="#XCALibre.ModelPhysics.Incompressible"><code>XCALibre.ModelPhysics.Incompressible</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Incompressible &lt;: AbstractIncompressible</code></pre><p>Incompressible fluid model containing fluid field parameters for incompressible flows.</p><p><strong>Fields</strong></p><ul><li>&#39;nu&#39;   – Fluid kinematic viscosity.</li><li>&#39;rho&#39;  – Fluid density.</li></ul><p><strong>Examples</strong></p><ul><li><code>Fluid{Incompressible}(nu=0.001, rho=1.0)</code> - Constructor with default values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/2_fluid_models.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.KOmega" href="#XCALibre.ModelPhysics.KOmega"><code>XCALibre.ModelPhysics.KOmega</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KOmega &lt;: AbstractTurbulenceModel</code></pre><p>kOmega model containing all kOmega field parameters.</p><p><strong>Fields</strong></p><ul><li>&#39;k&#39; – Turbulent kinetic energy ScalarField.</li><li>&#39;omega&#39; – Specific dissipation rate ScalarField.</li><li>&#39;nut&#39; – Eddy viscosity ScalarField.</li><li>&#39;kf&#39; – Turbulent kinetic energy FaceScalarField.</li><li>&#39;omegaf&#39; – Specific dissipation rate FaceScalarField.</li><li>&#39;nutf&#39; – Eddy viscosity FaceScalarField.</li><li>&#39;coeffs&#39; – Model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_kOmega.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.KOmegaLKE" href="#XCALibre.ModelPhysics.KOmegaLKE"><code>XCALibre.ModelPhysics.KOmegaLKE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KOmegaLKE &lt;: AbstractTurbulenceModel</code></pre><p>kOmega model containing all kOmega field parameters.</p><p><strong>Fields</strong></p><ul><li>&#39;k&#39; – Turbulent kinetic energy ScalarField.</li><li>&#39;omega&#39; – Specific dissipation rate ScalarField.</li><li>&#39;kl&#39; – ScalarField.</li><li>&#39;nut&#39; – Eddy viscosity ScalarField.</li><li>&#39;kf&#39; – Turbulent kinetic energy FaceScalarField.</li><li>&#39;omegaf&#39; – Specific dissipation rate FaceScalarField.</li><li>&#39;klf&#39; – FaceScalarField.</li><li>&#39;nutf&#39; – Eddy viscosity FaceScalarField.</li><li>&#39;coeffs&#39; – Model coefficients.</li><li>&#39;Tu&#39; – Freestream turbulence intensity for model.</li><li>&#39;y&#39; – Near-wall distance for model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_kOmegaLKE.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.LES" href="#XCALibre.ModelPhysics.LES"><code>XCALibre.ModelPhysics.LES</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LES &lt;: AbstractLESModel</code></pre><p>Abstract LES model type for constructing LES models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/turbulence_types.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Laminar" href="#XCALibre.ModelPhysics.Laminar"><code>XCALibre.ModelPhysics.Laminar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laminar &lt;: AbstractTurbulenceModel</code></pre><p>Laminar model definition for physics API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_laminar.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Momentum" href="#XCALibre.ModelPhysics.Momentum"><code>XCALibre.ModelPhysics.Momentum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Momentum{V,S,SS} &lt;: AbstractMomentumModel
    U::V 
    p::S 
    sources::SS
end</code></pre><p>Momentum model containing key momentum fields.</p><p><strong>Fields</strong></p><ul><li>&#39;U&#39;        – Velocity VectorField.</li><li>&#39;p&#39;        – Pressure ScalarField.</li><li>&#39;sources&#39;  – Momentum model sources.</li></ul><p><strong>Examples</strong></p><ul><li>`Momentum(mesh::AbstractMesh)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/0_type_definition.jl#L69-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Physics" href="#XCALibre.ModelPhysics.Physics"><code>XCALibre.ModelPhysics.Physics</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Physics{T,F,M,Tu,E,D,BI}
    time::T
    fluid::F
    momentum::M 
    turbulence::Tu 
    energy::E
    domain::D
    boundary_info::BI
end</code></pre><p>XCALibre&#39;s parametric Physics type for user-level API. Also used to dispatch flow solvers.</p><p><strong>Fields</strong></p><ul><li>&#39;time::Union{Steady, Transient}&#39;   – User-provided time model.</li><li>&#39;fluid::AbstractFluid&#39;  – User-provided <code>Fluid</code>` model.</li><li>&#39;momentum&#39;  – Momentum model. Currently this is auto-generated by the <code>Physics</code> constructor</li><li>&#39;turbulence::AbstractTurbulenceModel&#39;  – User-provided <code>Turbulence</code>` model.</li><li>&#39;energy:AbstractEnergyModel&#39;  – User-provided <code>Energy</code> model.</li><li>&#39;domain::AbstractMesh &#39;  – User-provided <code>Mesh</code>. Must be adapted to target device before constructing a Physics object.</li><li>&#39;boundary<em>info::boundary</em>info&#39;  – Mesh boundary information.  Auto-generated by the <code>Physics</code> constructor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/0_type_definition.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Physics-Tuple{}" href="#XCALibre.ModelPhysics.Physics-Tuple{}"><code>XCALibre.ModelPhysics.Physics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Physics(; time, fluid, turbulence, energy, domain)::Physics{T,F,M,Tu,E,D,BI}</code></pre><p><code>Physics</code> constructor part of the top-level API. It can be used to define the Physics and models relevant to a simulation. This constructor uses keyword arguments to allow users to fine-tune their simulations, whilst some fields are auto-generated behind the scenes for convenience (<code>Momentum</code> and <code>boundary_info</code>). Where:</p><ul><li><code>time</code> - specified the time model (Steady or Transient)</li><li><code>fluid</code> - specifies the type of fluid (Incompressible, etc.)</li><li><code>turbulence</code> - specified the Turbulence model</li><li><code>energy</code> - specifies the Energy treatment</li><li><code>domain</code> - provides the mesh to used (must be adapted to the target backend device)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/0_type_definition.jl#L100-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.RANS" href="#XCALibre.ModelPhysics.RANS"><code>XCALibre.ModelPhysics.RANS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RANS &lt;: AbstractRANSModel</code></pre><p>Abstract RANS model type for consturcting RANS models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/turbulence_types.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.SensibleEnthalpy" href="#XCALibre.ModelPhysics.SensibleEnthalpy"><code>XCALibre.ModelPhysics.SensibleEnthalpy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SensibleEnthalpy &lt;: AbstractEnergyModel</code></pre><p>Type that represents energy model, coefficients and respective fields.</p><p><strong>Fields</strong></p><ul><li>&#39;h&#39;    – Sensible enthalpy ScalarField.</li><li>&#39;T&#39;    – Temperature ScalarField.</li><li>&#39;hf&#39;   – Sensible enthalpy FaceScalarField.</li><li>&#39;Tf&#39;   – Temperature FaceScalarField.</li><li>&#39;K&#39;    – Specific kinetic energy ScalarField.</li><li>&#39;dpdt&#39; – Pressure time derivative ScalarField.</li><li>&#39;updated_BC&#39; – Boundary condition function to convert temperature to sensible enthalp on                    on a fixed value boudary.</li><li>&#39;coeffs&#39; – A tuple of model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Smagorinsky" href="#XCALibre.ModelPhysics.Smagorinsky"><code>XCALibre.ModelPhysics.Smagorinsky</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Smagorinsky &lt;: AbstractTurbulenceModel</code></pre><p>Smagorinsky LES model containing all Smagorinksy field parameters.</p><p><strong>Fields</strong></p><ul><li>&#39;nut&#39; – Eddy viscosity ScalarField.</li><li>&#39;nutf&#39; – Eddy viscosity FaceScalarField.</li><li>&#39;coeffs&#39; – Model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/LES_Smagorinsky.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Steady" href="#XCALibre.ModelPhysics.Steady"><code>XCALibre.ModelPhysics.Steady</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Steady</code></pre><p>Steady model for Physics model API.</p><p><strong>Examples</strong></p><ul><li><code>Steady()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/0_type_definition.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Transient" href="#XCALibre.ModelPhysics.Transient"><code>XCALibre.ModelPhysics.Transient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transient</code></pre><p>Transient model for Physics model API.</p><p><strong>Examples</strong></p><ul><li><code>Transient()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/0_type_definition.jl#L43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.WeaklyCompressible" href="#XCALibre.ModelPhysics.WeaklyCompressible"><code>XCALibre.ModelPhysics.WeaklyCompressible</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeaklyCompressible &lt;: AbstractCompressible</code></pre><p>Weakly compressible fluid model containing fluid field parameters for weakly compressible      flows with constant parameters - ideal gas with constant viscosity.</p><p><strong>Fields</strong></p><ul><li>&#39;nu&#39;   – Fluid kinematic viscosity.</li><li>&#39;cp&#39;   – Fluid specific heat capacity.</li><li><code>gamma</code> – Ratio of specific heats.</li><li><code>Pr</code>   – Fluid Prandtl number.</li></ul><p><strong>Examples</strong></p><ul><li><code>Fluid{WeaklyCompressible}(; nu=1E-5, cp=1005.0, gamma=1.4, Pr=0.7)</code> - Constructor with </li></ul><p>default values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/2_fluid_models.jl#L61-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Ttoh!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.Ttoh!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.Ttoh!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ttoh!(model::Physics{T1,F,M,Tu,E,D,BI}, T::ScalarField, h::ScalarField
) where {T1,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Function coverts temperature ScalarField to sensible enthalpy ScalarField.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>T</code>      – Temperature ScalarField.</li><li><code>h</code>      – Sensible enthalpy ScalarField.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L267-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.change-Tuple{Physics, Any, Any}" href="#XCALibre.ModelPhysics.change-Tuple{Physics, Any, Any}"><code>XCALibre.ModelPhysics.change</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change(model::Physics, property, value) =&gt; updatedModel::Physics</code></pre><p>A convenience function to change properties of an exisitng <code>Physics</code> model.</p><p><strong>Input arguments</strong></p><ul><li><code>model::Physics</code> a <code>Physics</code> model to modify</li><li><code>property</code> is a symbol specifying the property to change </li><li><code>value</code> is the new setting for the specified <code>property</code></li></ul><p><strong>Output</strong></p><p>This function return a new <code>Physics</code> object</p><p><strong>Example</strong></p><p>To change a model to run a transient simulation e.g. after converging in steady state</p><pre><code class="nohighlight hljs">modelTransient = change(model, :time, Transient())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/3_physics_API.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.energy!-Union{Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{XCALibre.ModelPhysics.Sensible_Enthalpy_Model{E1}, Physics{T1, F, M, Tu, E, D, BI}, Vararg{Any, 6}}} where {T1, F, M, Tu, E, D, BI, E1}" href="#XCALibre.ModelPhysics.energy!-Union{Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{XCALibre.ModelPhysics.Sensible_Enthalpy_Model{E1}, Physics{T1, F, M, Tu, E, D, BI}, Vararg{Any, 6}}} where {T1, F, M, Tu, E, D, BI, E1}"><code>XCALibre.ModelPhysics.energy!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">energy::Sensible_Enthalpy_Model{E1}, model::Physics{T1,F,M,Tu,E,D,BI}, prev, mdotf, rho, mueff, time, config
) where {T1,F,M,Tu,E,D,BI,E1}</code></pre><p>Run energy transport equations.</p><p><strong>Input</strong></p><ul><li><code>energy</code> – Energy model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>prev</code>   – Previous energy cell values.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>rho</code>    – Density ScalarField.</li><li><code>mueff</code>  – Effective viscosity FaceScalarField.</li><li><code>time</code>   –</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L123-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.htoT!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.htoT!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.htoT!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">htoT!(model::Physics{T1,F,M,Tu,E,D,BI}, h::ScalarField, T::ScalarField
) where {T1,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Function coverts sensible enthalpy ScalarField to temperature ScalarField.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>h</code>      – Sensible enthalpy ScalarField.</li><li><code>T</code>      – Temperature ScalarField.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L287-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{SensibleEnthalpy, Physics{T1, F, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T1, F, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T1}, Tuple{SensibleEnthalpy, Physics{T1, F, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T1, F, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise(energy::SensibleEnthalpy, model::Physics{T1,F,M,Tu,E,D,BI}, mdotf, rho, peqn, config
) where {T1,F,M,Tu,E,D,BI})</code></pre><p>Initialisation of energy transport equations.</p><p><strong>Input</strong></p><ul><li><code>energy</code> – Energy model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>rho</code>    – Density ScalarField.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>Sensible_Enthalpy_Model</code>  – Energy model struct containing energy equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L67-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{KOmega, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{KOmega, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise(turbulence::KOmega, model::Physics{T,F,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>KOmegaModel(k_eqn, ω_eqn)</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_kOmega.jl#L59-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{KOmegaLKE, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{KOmegaLKE, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise(turbulence::KOmegaLKE, model::Physics{T,F,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>KOmegaLKEModel(       k_eqn,       ω_eqn,       kl_eqn,       nueffkLS,       nueffkS,       nueffωS,       nuL,       nuts,       Ω,       γ,       fv,       normU,       Reυ,       ∇k,       ∇ω   )</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_kOmegaLKE.jl#L113-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Laminar, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Laminar, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function initialise(
    turbulence::Laminar, model::Physics{T,F,M,Tu,E,D,BI}, mdotf, peqn, config
    ) where {T,F,M,Tu,E,D,BI}
return LaminarModel()</code></pre><p>end</p><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>LaminarModel()</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_laminar.jl#L26-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Smagorinsky, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Smagorinsky, Physics{T, F, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise(turbulence::Smagorinsky, model::Physics{T,F,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>SmagorinskyModel(Δ, magS)</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/LES_Smagorinsky.jl#L44-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, FaceScalarField, Any}} where {T, F&lt;:AbstractCompressible, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, FaceScalarField, Any}} where {T, F&lt;:AbstractCompressible, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.thermo_Psi!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thermo_Psi!(model::Physics{T,F,M,Tu,E,D,BI}, Psif::FaceScalarField) 
where {T,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Function updates the value of Psi.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>Psif</code>    – Compressibility factor FaceScalarField.</li></ul><p><strong>Algorithm</strong></p><p>Weakly compressible currently uses the ideal gas equation for establishing the compressibility factor where <span>$\rho = p * \Psi$</span>. <span>$\Psi$</span> is calculated from the sensible  enthalpy, reference temperature and fluid model specified <span>$C_p$</span> and <span>$R$</span> value where  <span>$R$</span> is calculated from <span>$C_p$</span> and <span>$\gamma$</span> specified in the fluid model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L240-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, ScalarField}} where {T, F&lt;:AbstractCompressible, M, Tu, E, D, BI}" href="#XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, ScalarField}} where {T, F&lt;:AbstractCompressible, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.thermo_Psi!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thermo_Psi!(model::Physics{T,F,M,Tu,E,D,BI}, Psi::ScalarField) 
where {T,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Model updates the value of Psi.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>Psi</code>    – Compressibility factor ScalarField.</li></ul><p><strong>Algorithm</strong></p><p>Weakly compressible currently uses the ideal gas equation for establishing the compressibility factor where <span>$\rho = p * \Psi$</span>. <span>$\Psi$</span> is calculated from the sensible  enthalpy, reference temperature and fluid model specified <span>$C_p$</span> and <span>$R$</span> value where  <span>$R$</span> is calculated from <span>$C_p$</span> and <span>$\gamma$</span> specified in the fluid model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L215-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Turb}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaLKEModel, Physics{T, F, M, Turb, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Turb&lt;:KOmegaLKE, E, D, BI}" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Turb}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaLKEModel, Physics{T, F, M, Turb, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Turb&lt;:KOmegaLKE, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>turbulence!(rans::KOmegaLKEModel, model::Physics{T,F,M,Turb,E,D,BI}, S, S2, prev, time, config     ) where {T,F,M,Turb&lt;:KOmegaLKE,E,D,BI}</p><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::KOmegaLKEModel</code> – KOmega turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>S2</code>  – Square of the strain rate magnitude.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_kOmegaLKE.jl#L260-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.LaminarModel, Physics{T, F, M, Tu, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Tu&lt;:Laminar, E, D, BI}" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.LaminarModel, Physics{T, F, M, Tu, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Tu&lt;:Laminar, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">turbulence!(rans::LaminarModel, model::Physics{T,F,M,Tu,E,D,BI}, S, S2, prev, time, config
) where {T,F,M,Tu&lt;:Laminar,E,D,BI}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::LaminarModel</code> – Laminar turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>S2</code>  – Square of the strain rate magnitude.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_laminar.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaModel{E1, E2}, Physics{T, F, M, Tu, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Tu&lt;:KOmega, E, D, BI, E1, E2}" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaModel{E1, E2}, Physics{T, F, M, Tu, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Tu&lt;:KOmega, E, D, BI, E1, E2}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">turbulence!(rans::KOmegaModel{E1,E2}, model::Physics{T,F,M,Tu,E,D,BI}, S, S2, prev, time, config
) where {T,F,M,Tu&lt;:KOmega,E,D,BI,E1,E2}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::KOmegaModel{E1,E2}</code> – KOmega turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>S2</code>  – Square of the strain rate magnitude.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/RANS_kOmega.jl#L130-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.SmagorinskyModel{E1, E2}, Physics{T, F, M, Tu, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Tu&lt;:Smagorinsky, E, D, BI, E1, E2}" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.SmagorinskyModel{E1, E2}, Physics{T, F, M, Tu, E, D, BI}, Vararg{Any, 5}}} where {T, F, M, Tu&lt;:Smagorinsky, E, D, BI, E1, E2}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">turbulence!(les::SmagorinskyModel{E1,E2}, model::Physics{T,F,M,Tu,E,D,BI}, S, S2, prev, time, config
) where {T,F,M,Tu&lt;:Smagorinsky,E,D,BI,E1,E2}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>les::SmagorinskyModel{E1,E2}</code> – Smagorinsky LES turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>S2</code>  – Square of the strain rate magnitude.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/ModelPhysics/Turbulence/LES_Smagorinsky.jl#L79-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Simulate.Configuration" href="#XCALibre.Simulate.Configuration"><code>XCALibre.Simulate.Configuration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Configuration{SC,SL,RT,HW}
    schemes::SC
    solvers::SL
    runtime::RT
    hardware::HW
end</code></pre><p>The <code>Configuration</code> type is passed to all flow solvers and provides all the relevant information to run a simulation. </p><p><strong>Inputs</strong></p><ul><li><code>schemes::NamedTuple</code> this keyword argument is used to pass distretisation scheme information to flow solvers. See <a href="../user_guide/3_numerical_setup/#Numerical-setup">Numerical setup</a> for details.</li><li><code>solvers::NamedTuple</code> this keyword argument is used to pass the configurations for the linear solvers for each field information to flow solvers. See <a href="../user_guide/4_runtime_and_solvers/#Runtime-and-solvers">Runtime and solvers</a> for details.</li><li><code>runtime::NamedTuple</code> this keyword argument is used to pass runtime information to the flow solvers. See <a href="../user_guide/4_runtime_and_solvers/#Runtime-and-solvers">Runtime and solvers</a> for details.</li><li><code>hardware::NamedTuple</code> this keyword argument is used to pass the hardware configuration and backend settings to the flow solvers. See <a href="../user_guide/1_preprocessing/#Pre-processing">Pre-processing</a> for details.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">config = Configuration(
    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Simulate/Simulate_0_types.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Simulate.set_hardware-Tuple{}" href="#XCALibre.Simulate.set_hardware-Tuple{}"><code>XCALibre.Simulate.set_hardware</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hardware = set_hardware(backend, workgroup)</code></pre><p>Function used to configure the backend.</p><p><strong>Inputs</strong></p><ul><li><code>backend</code> named tuple used to specify the backend e.g. <code>CPU()</code>, <code>CUDABackend()</code> or other backends supported by <code>KernelAbstraction.jl</code></li><li><code>workgroup::Int</code> this is an integer specifying the number of workers that cooperate in a parallel run. For GPUs this could be set to the size of the device&#39;s warp e.g. <code>workgroup = 32</code>. On CPUs, the default value in <code>KernelAbstractions.jl</code> is currently <code>workgroup = 1024</code>.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> with the fields <code>backend</code> and <code>workgroup</code> which are accessed by internally in <code>XCALibre.jl</code> to execute a given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Simulate/Simulate_0_types.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.cpiso!-Tuple{Any, Any}" href="#XCALibre.Solvers.cpiso!-Tuple{Any, Any}"><code>XCALibre.Solvers.cpiso!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cpiso!(model, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Compressible and transient variant of the PISO algorithm with a sensible enthalpy transport equation for the energy. </p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>limit_gradient</code> flag use to activate gradient limiters in the solver (default = <code>false</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_2_CPISO.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.csimple!-Tuple{Any, Any}" href="#XCALibre.Solvers.csimple!-Tuple{Any, Any}"><code>XCALibre.Solvers.csimple!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">csimple!(
    model_in, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0
)</code></pre><p>Compressible variant of the SIMPLE algorithm with a sensible enthalpy transport equation for the energy. </p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>limit_gradient</code> flag use to activate gradient limiters in the solver (default = <code>false</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li><li><code>e</code> Vector of energy residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_1_CSIMPLE.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.piso!-Tuple{Any, Any}" href="#XCALibre.Solvers.piso!-Tuple{Any, Any}"><code>XCALibre.Solvers.piso!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cpiso!(model, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Incompressible and transient variant of the SIMPLE algorithm to solving coupled momentum and mass conservation equations. </p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>limit_gradient</code> flag use to activate gradient limiters in the solver (default = <code>false</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_2_PISO.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.run!-Tuple{}" href="#XCALibre.Solvers.run!-Tuple{}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function run!(
    model::Physics, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0
    )

    # here an internal function is used for solver dispatch
    return residuals
end</code></pre><p>This is the top level API function to initiate a simulation. It uses the user-provided <code>model</code> defined as a <code>Physics</code> object to dispatch to the appropriate solver.</p><p><strong>Dispatched flow solvers</strong></p><ul><li>Steady incompressible (SIMPLE algorithm for coupling)</li><li>Transient incompressible (PISO algorithm for coupling)</li><li>Steady weakly compressible (SIMPLE algorithm for coupling)</li><li>Transient weakly compressible (PISO algorithm for coupling)</li></ul><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>limit_gradient</code> flag used to activate gradient limiters in the solver (default = <code>false</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>). The fields available within the returned <code>residuals</code> tuple depend on the solver used. For example, for an incompressible solver, a x-momentum equation residual can be retrieved accessing the <code>Ux</code> field i.e. <code>residuals.Ux</code>. Look at reference guide for each dispatch method to find out which fields are available.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">residuals = run!(model, config) 

# to access the pressure residual

residuals.p </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_3_solver_dispatch.jl#L3-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:Incompressible, M, Tu, E, D, BI}" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:Incompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}, config;
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Steady,F&lt;:Incompressible,M,Tu,E,D,BI} = 
begin
    residuals = simple!(model, config, pref=pref)
    return residuals
end</code></pre><p>Calls the incompressible steady solver using the SIMPLE algorithm.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_3_solver_dispatch.jl#L48-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Steady,F&lt;:WeaklyCompressible,M,Tu,E,D,BI} = 
begin
    residuals = csimple!(model, config, pref=pref); #, pref=0.0)
    return residuals
end</code></pre><p>Calls the compressible steady solver using the SIMPLE algorithm for weakly compressible fluids.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li><li><code>e</code>   - Vector of energy residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_3_solver_dispatch.jl#L134-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:Incompressible, M, Tu, E, D, BI}" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:Incompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Transient,F&lt;:Incompressible,M,Tu,E,D,BI} = 
begin
    residuals = piso!(model, config, pref=pref); #, pref=0.0)
    return residuals
end</code></pre><p>Calls the incompressible transient solver using the PISO algorithm.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_3_solver_dispatch.jl#L90-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Transient,F&lt;:WeaklyCompressible,M,Tu,E,D,BI} = 
begin
    residuals = cpiso!(model, config)
    return residuals
end</code></pre><p>Calls the compressible transient solver using the PISO algorithm for weakly compressible fluids.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li><li><code>e</code>   - Vector of energy residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_3_solver_dispatch.jl#L195-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Solvers.simple!-Tuple{Any, Any}" href="#XCALibre.Solvers.simple!-Tuple{Any, Any}"><code>XCALibre.Solvers.simple!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simple!(model_in, config; 
    limit_gradient=false, pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Incompressible variant of the SIMPLE algorithm to solving coupled momentum and mass conservation equations.</p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>limit_gradient</code> flag use to activate gradient limiters in the solver (default = <code>false</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Solvers/Solvers_1_SIMPLE.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Postprocess.boundary_average-Tuple{Symbol, Any, Any}" href="#XCALibre.Postprocess.boundary_average-Tuple{Symbol, Any, Any}"><code>XCALibre.Postprocess.boundary_average</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function boundary_average(patch::Symbol, field, config; time=0)
    # Extract mesh object
    mesh = field.mesh

    # Determine ID (index) of the boundary patch 
    ID = boundary_index(mesh.boundaries, patch)
    @info &quot;calculating average on patch: $patch at index $ID&quot;
    boundary = mesh.boundaries[ID]
    (; IDs_range) = boundary

    # Create face field of same type provided by user (scalar or vector)
    sum = nothing
    if typeof(field) &lt;: VectorField 
        faceField = FaceVectorField(mesh)
        sum = zeros(_get_float(mesh), 3) # create zero vector
    else
        faceField = FaceScalarField(mesh)
        sum = zero(_get_float(mesh)) # create zero
    end

    # Interpolate CFD results to boundary
    interpolate!(faceField, field, config)
    correct_boundaries!(faceField, field, field.BCs, time, config)

    # Calculate the average
    for fID ∈ IDs_range
        sum += faceField[fID]
    end
    ave = sum/length(IDs_range)

    # return average
    return ave
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Postprocess/Postprocess_functions.jl#L85-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Postprocess.pressure_force-Tuple{Symbol, ScalarField, Any}" href="#XCALibre.Postprocess.pressure_force-Tuple{Symbol, ScalarField, Any}"><code>XCALibre.Postprocess.pressure_force</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pressure_force(patch::Symbol, p::ScalarField, rho)</code></pre><p>Function to calculate the pressure force acting on a given patch/boundary.</p><p><strong>Input arguments</strong></p><ul><li><code>patch::Symbol</code> name of the boundary of interest (as a <code>Symbol</code>)</li><li><code>p::ScalarField</code> pressure field</li><li><code>rho</code> density. Set to 1 for incompressible solvers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Postprocess/Postprocess_functions.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Postprocess.viscous_force-Tuple{Symbol, VectorField, Any, Any, Any}" href="#XCALibre.Postprocess.viscous_force-Tuple{Symbol, VectorField, Any, Any, Any}"><code>XCALibre.Postprocess.viscous_force</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viscous_force(patch::Symbol, U::VectorField, rho, ν, νt)</code></pre><p>Function to calculate the pressure force acting on a given patch/boundary.</p><p><strong>Input arguments</strong></p><ul><li><code>patch::Symbol</code> name of the boundary of interest (as a <code>Symbol</code>)</li><li><code>U::VectorField</code> pressure field</li><li><code>rho</code> density. Set to 1 for incompressible solvers</li><li><code>ν</code> laminar viscosity of the fluid</li><li><code>νt</code> eddy viscosity from turbulence models. Pass ConstantScalar(0) for laminar flows</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/866cb0f2d6fa3bd5900545d6ac8e0233320407d9/src/Postprocess/Postprocess_functions.jl#L38-L50">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributor_guide/">« Contributor Guide</a><a class="docs-footer-nextpage" href="../release_notes/">Release notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 21 November 2024 20:16">Thursday 21 November 2024</span>. Using Julia version 1.10.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
